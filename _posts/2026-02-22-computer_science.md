---
layout: post
title: "기초적인 컴퓨터 과학"
date: 2026-02-22
categories: []
tags: []
---
###### 이 글은 씹어먹는 C언어의 강의를 공부용으로 정리하고 내용을 추가하여 올린 것입니다.
# 컴퓨터란?
컴퓨터는 **명령어를 읽어들여서 읽어들인 명령어에 따라 연산을 수행하는 장치**이다.
> 💡
> 리눅스의 poweroff 명령어 같은 건 연산이 아니라고 착각을 할 수 있다. 
> 하지만 여기서 말하는 연산은 1+1 같은 **산술 연산만이 아니라 논리적인 연산(AND,OR 등등)을 담당하는 논리 연산 등등이 포함**된다.

---

## Who (누가 명령어를 읽는가?)
컴퓨터에서 일어나는 대부분의 연산은 CPU라는 장치에서 처리된다.
GPU,NPU,QPU등등 컴퓨터에서 연산을 처리하는 장치는 많지만 
PC에서는 CPU와 GPU만을 사용하고 GPU는 다양한 명령어를 처리하지 못하므로 범용적인 명령어들은 CPU에서 처리된다고 봐도 무방하다.

---

## Where (어디서 명령어를 읽는가?)
CPU가 명령을 실행하려면 **명령어를 어디선가 읽어와야하고, 연산 결과를 어딘가엔 저장을 해야한다**.
하지만 CPU는 연산 특화 장치이므로 저장 공간을 확보하기는 어렵다. 하지만 저장공간이 없는 것은 아니다 CPU 내부에는 **레지스터** 라는 것이 있는데, 
이는 CPU가 연산을 수행하기 위해 데이터를 저장하는 공간을 말한다.
64비트 프로세서에는 레지스터에 64비트를, 32비트 프로세서는 레지스터에 32비트까지 저장이 가능하다. 
x86-64 아키텍쳐 CPU라는 것에는 16개의 레지스터가 있고 ARM64에는 31개가 있다.
레지스터는 CPU 내부에 있으므로 접근 속도가 빠르지만 용량이 작다.
기술적인 한계에 의해서 레지스터의 개수를 늘릴 수는 없다.
> ##### 단순하게 생각하면 그냥 CPU의 크기를 늘리면 되는게 아닌가 싶다. 하지만 CPU는 크기가 작으므로 칩 내부에서 이동하는 속도가 물리적으로 빠르기 때문에 지금과 같은 속도를 낼 수 있는 것이다. 그러므로 레지스터의 개수를 늘리면 CPU의 성능이 안좋아지는 단점이 생긴다
> ##### 또 더 단순하게 생각하면 그냥 CPU에 내부에 있는 칩의 크기를 줄이면 된다고 생각할 수 있다. 하지만 최근 CPU는 3나노 공정 , 4나노 공정 같이 매우 작은 단위로 만든다(원자 몇개를 이어 붙인 수준). 여기서 더 작게 만든다면 양자터널링이라는 효과 때문에 문제가 생긴다. 양자터널링이란 회로가 너무 작아지면 전자가 벽을 통과하는 이상한 현상이 발생한다.

레지스터는 용량의 문제가 있으므로 어쩔 수 없이 CPU 밖에 있는 저장 공간을 사용해야한다.
### RAM
그래서 사용하는게 **RAM**이다.
RAM의 용량은 16GB,32GB,64GB,128GB등등 다양하지만 16GB만 되어도 **레지스터보다 비교가 안되게 크다**는 것을 알 수 있다.
그러면 RAM만 있으면 되겠네? 라고 생각 할 수 있다. 하지만 여기서 RAM의 치명적 단점을 알 수 있다.
바로 RAM은 **휘발성 메모리** 라는 것이다.
휘발성 메모리라는게 무엇이냐면, 바로 전기가 차단되면 메모리에 있던 데이터들이 싹 다 날아간다.
그렇다고 컴퓨터를 계속 켜놓을 수도 없을 것 같다.
그래서 사용하는 것이 SSD,HDD이다 이것들은 램과 다르게 전기가 차단되어도 데이터를 안정적으로 보관할 수 있다.
> ##### 이래서 우리는 컴퓨터를 킬때마다 게임을 다운로드 받지 않아도 된다.

물론 램과 SSD,HDD는 레지스터보다 물리적인 거리가 길기 때문에 데이터를 불러오는 속도가 비약적으로 느리다.

위에 내용을 바탕으로 프로그램을 실행하면 SSD나 HDD에서 프로그램의 위치를 램에 복사 --> CPU는 램에서 명령어를 읽어들여서 실행을 한다고 볼 수 있다.
물론 램에서 CPU까지 불러오는 속도도 빠르진 않다.
### Cache
램에서 CPU까지 불러오는 속도가 빠르지 않다는 점을 개선하기 위해서 캐시라는 것을 사용한다.
캐시에선 직접적인 연산을 수행하는 것이 불가하다. 하지만 빠르게 데이터를 레지스터에 불러올 수 있는 공간으로 사용한다.
캐시는 3계층으로 나누어 중요도에 따라 불러오는 데이터를 달리한다.
L1 캐시는 용량이 제일 작고 레지스터에서 제일 가깝다. 중요도가 가장 큰 데이터를 보관한다.
L2 캐시는 용량이 L1보다 크고 L3보다 작다. 레지스터와의 물리적인 거리도 L1과 L3의 중간이다. 중요도는 L1보다 덜 중요한 데이터를 보관한다.
L3 캐시는 용량이 가장 크고 레지스터에서 제일 멀다. 중요도가 가장 낮은 데이터를 보관한다. 
> ##### 여기서 매우 합리적인 의구심이 든다 L3 캐시가 용량이 제일 큰데 이걸 레지스터랑 제일 가깝게 하고 중요한 데이터를 보관하면 되는거 아니야? 라는 의문이다 하지만 그렇게 하지 않는 이유는 데이터에서 필요한 데이터를 찾는 시간이 오래 걸리기 때문이다 비유를 하자면 요리사의 앞주머니가 접근성이 가장 좋지만 담을 수 있는 양이 작다. 하지만 양이 작으므로 빨리 빨리 찾아서 꺼내 쓸 수 있다. L3캐시를 레지스터에 가까이 두고 중요한 데이터를 보관하는건 요리사가 냉장고를 앞에 매고 있는 것과 같다. 이는 필요한 것을 찾기 어렵게 만든다.

CPU는 자기가 사용할 데이터들을 캐시에 불러온다.
또한 램에 데이터를 작성할때도 램에 바로 작성하지 않고 캐시에 데이터를 넣어놨다가 램에 용량 여유가 생기면 램에 작성하는 방식을 사용하기도 한다.
당연하게도 CPU가 실행할 명령어를 미리 보는 것은 마법에 가깝기에 다양한 예측 알고리즘을 사용하여 캐시의 적중률을 높이려고 한다.

너무나 당연하게도 CPU가 요청한 데이터가 캐시에 없는 상황도 존재한다 이 경우에는 예측 알고리즘이 틀린 경우이고 이 경우를 **캐시 미스** 라고 한다.
캐시 미스가 일어나면 램에서 데이터를 가져와야 하기 때문에 진행 상황이 느려진다.
즉, 빠른 프로그램을 설계하기 위해선 캐시 미스를 줄이는 것이 중요 쟁점으로 뽑힐 수 있다.
### CPU에서의 접근 속도 비교
CPU에서 접근 속도로 정리해보면 레지스터, L1 캐시, L2 캐시, L3 캐시, RAM, SSD, HDD순으로 느려진다고 볼 수 있다.

---
## HOW (명령어는 어떻게 작성하는가)
램의 구조를 보면 데이터들은 1바이트 단위로 나누어진 공간에 담길 수 있다. 
각 공간엔 0번부터 시작하는 고유한 주소가 있다.
CPU가 램에 있는 데이터를 읽으려면 어디서 읽어올지 주소를 지정해줘야한다.
CPU가 램에 데이터를 저장하려면 어디에다가 저장할지 주소를 지정해줘야한다.

CPU가 램에서 데이터를 읽어오려고 주소를 지정하면 단순히 그 주소에 있는 데이터를 불러오면 된다.
CPU가 램에서 데이터를 저장하려고 주소를 지정하면 이미 그 주소에 있는 데이터가 있을 수 있기 때문에 문제가 생긴다.
그래서 램은 CPU한테 받은 데이터를 CPU한테 받은 주소에 **덮어쓰기** 한다.
즉, 원래 주소에 있던 데이터는 사라진다.
그리고, CPU는 램에 데이터를 저장하거나 읽어올때 주소와 그 주소부터 얼마나 읽거나 저장할지도 알려줘야한다.
즉, 어떤 데이터를 저장할때 0x12345에다가 120이라는 데이터를 3바이트만큼 저장하면 0x12345을 포함해서 3칸에 120이라는 데이터가 저장되는 것이다.

요약하자면 램은 1바이트 단위로 나눠진 주소가 부여되 있고
CPU가 램에 데이터를 저장하거나 읽어올려면 **램의 주소(어디에),데이터(무엇을),데이터의 크기(얼마나)**를 램에게 알려줘야 하고, 
램은 지정받은 주소부터 지정 받은 데이터를 지정받은 크기만큼 칸을 차지해서 저장(덮어쓰기)한다.

> ###### 램은 1바이트로 나눠져 있는 칸이 있는 것이지, 데이터를 딱 1바이트만 저장해야하는 것은 아니다.

---

## HOW2 (CPU는 어떻게 명령어를 읽어들이는가?)
CPU가 명령어를 내리기 위해선 명령어를 가져와야한다.
CPU에게 명령어를 제공하는 것을 프로그램을 실행한다고 표현한다.
프로그램을 실행하게 되면, OS가 램에 있는 시작점의 위치를 CPU에게 알려준다. 그 후엔 CPU가 시작점의 위치부터 명령어를 읽어나가며 실행하게 된다.

